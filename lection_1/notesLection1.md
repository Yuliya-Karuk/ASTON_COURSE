## Number
### Cпособы записи числа

- let billion = 1000000000;
- let billion = 1_000_000_000;
- let billion = 1e9;

Для других систем счисления:

- Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
- parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
- num.toString(base) представляет число в строковом виде в указанной системе счисления base.

### Методы округления
- Math.floor
- Math.ceil
- Math.round
- Math.trunc
- num.toFixed(n) -  возвращает строку

#### Как избавиться от неточности при вычеслении  0.1 + 0.2  // 0.30000000000000004
- +sum.toFixed(2)
- (0.1 * 10 + 0.2 * 10) / 10


### Числовые проверки
Для проверки на NaN и Infinity:

- isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
- Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN
- isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity
- Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не является NaN/Infinity/-Infinity

NaN === NaN // false

alert( Number.isNaN("str" / 2) ); // true

// Обратите внимание на разный результат:
alert( Number.isNaN("str") ); // false, так как "str" является строкой, а не числом
alert( isNaN("str") ); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN

alert( Number.isFinite(2 / 0) ); // false

// Обратите внимание на разный результат:
alert( Number.isFinite("123") ); // false, так как "123" является строкой, а не числом
alert( isFinite("123") ); // true, так как isFinite сначала преобразует строку "123" в число 123

### Парсинг строк с числами
Для преобразования значений типа 12pt и 100px в число:
Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.

## Hoisting
1. Используя es5 переменную var, попытки использования необъявленных переменных приведут к тому, что переменной будет назначено значение undefined при «поднятии».

2. Используя переменные es6 let и const, использование переменных приведет к Reference Error, потому что переменная останется неинициализированной при выполнении.

## Типы данных
- Примитивные типы данных (числа, булевы и строки) хранятся и сравниваются по значению. Можно безопасно менять значение переменной и не бояться, что изменится что-то ещё
- Ссылочные типы данных (объекты, массивы) хранятся и сравниваются по ссылке. При этом при сравнении будет учитываться именно факт того, что две переменные ссылаются на один и тот же объект. Даже если два объекта содержат идентичные значения это ни на что не повлияет
- Изменения внутри объекта будут видны всем у кого есть ссылка на этот объект. Прямое изменение данных объекта называется мутирование. Лучше стараться избегать мутации объекта, т.к это может приводить к неочевидным ошибкам

## Операторы
Операторы ++ и -- могут быть расположены не только после, но и до переменной.

Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
«Префиксная форма» — это когда оператор идёт перед переменной: ++counter.

Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.